#!/usr/bin/env node
// @generated by xcode-mcp@1.0.0 on 2026-02-27T19:58:04.864Z. DO NOT EDIT.
import { Command } from 'commander';
import { createRuntime, createServerProxy } from 'mcporter';
import { createCallResult } from 'mcporter';

const embeddedServer = {
  "name": "mcpbridge",
  "description": "xcode-tools",
  "command": {
    "kind": "stdio",
    "command": "xcrun",
    "args": [
      "mcpbridge"
    ]
  },
  "source": {
    "kind": "local",
    "path": "<adhoc>"
  }
} as const;
const embeddedSchemas = {
  "XcodeUpdate": {
    "type": "object",
    "properties": {
      "filePath": {
        "description": "REQUIRED: The path to the file to modify within the Xcode project organization (e.g., 'ProjectName/Sources/MyFile.swift')",
        "type": "string"
      },
      "newString": {
        "description": "REQUIRED: The text to replace it with, must be different from oldString",
        "type": "string"
      },
      "oldString": {
        "description": "REQUIRED: The text to replace",
        "type": "string"
      },
      "replaceAll": {
        "description": "Replace all occurrences of oldString (default false)",
        "type": "boolean"
      },
      "tabIdentifier": {
        "description": "The workspace tab identifier",
        "type": "string"
      }
    },
    "required": [
      "tabIdentifier",
      "filePath",
      "oldString",
      "newString"
    ]
  },
  "XcodeMV": {
    "type": "object",
    "properties": {
      "destinationPath": {
        "description": "Project navigator relative path for the destination (for move) or new name (for rename)",
        "type": "string"
      },
      "operation": {
        "description": "The type of move operation to perform",
        "enum": [
          "move",
          "copy"
        ],
        "type": "string"
      },
      "overwriteExisting": {
        "description": "Whether to overwrite existing files at the destination",
        "type": "boolean"
      },
      "sourcePath": {
        "description": "Project navigator relative path of the source item to move/rename",
        "type": "string"
      },
      "tabIdentifier": {
        "description": "The workspace tab identifier",
        "type": "string"
      }
    },
    "required": [
      "tabIdentifier",
      "sourcePath",
      "destinationPath"
    ]
  },
  "XcodeRead": {
    "type": "object",
    "properties": {
      "filePath": {
        "description": "The path to the file within the Xcode project organization (e.g., 'ProjectName/Sources/MyFile.swift')",
        "type": "string"
      },
      "limit": {
        "description": "The number of lines to read (only provide if the file is too large to read at once)",
        "type": "integer"
      },
      "offset": {
        "description": "The line number to start reading from (only provide if the file is too large to read at once)",
        "type": "integer"
      },
      "tabIdentifier": {
        "description": "The workspace tab identifier",
        "type": "string"
      }
    },
    "required": [
      "tabIdentifier",
      "filePath"
    ]
  },
  "RunSomeTests": {
    "type": "object",
    "properties": {
      "tabIdentifier": {
        "description": "The workspace tab identifier",
        "type": "string"
      },
      "tests": {
        "description": "Array of test specifiers to run. Each specifier contains 'targetName' and 'testIdentifier' fields. Use GetTestList action to discover available tests and their identifiers, then extract the 'targetName' and 'identifier' fields from the TestActionInfo results to construct TestActionSpecifier objects.",
        "items": {
          "properties": {
            "targetName": {
              "description": "The test target name",
              "type": "string"
            },
            "testIdentifier": {
              "description": "Test identifier in XCTestIdentifier format",
              "type": "string"
            }
          },
          "required": [
            "targetName",
            "testIdentifier"
          ],
          "type": "object"
        },
        "type": "array"
      }
    },
    "required": [
      "tabIdentifier",
      "tests"
    ]
  },
  "XcodeRM": {
    "type": "object",
    "properties": {
      "deleteFiles": {
        "description": "Also move the underlying files to Trash (defaults to true)",
        "type": "boolean"
      },
      "path": {
        "description": "The project path to remove (e.g., 'ProjectName/Sources/MyFile.swift')",
        "type": "string"
      },
      "recursive": {
        "description": "Remove directories and their contents recursively",
        "type": "boolean"
      },
      "tabIdentifier": {
        "description": "The workspace tab identifier",
        "type": "string"
      }
    },
    "required": [
      "tabIdentifier",
      "path"
    ]
  },
  "XcodeRefreshCodeIssuesInFile": {
    "type": "object",
    "properties": {
      "filePath": {
        "description": "The path to the file within the Xcode project organization (e.g., 'ProjectName/Sources/MyFile.swift')",
        "type": "string"
      },
      "tabIdentifier": {
        "description": "The workspace tab identifier",
        "type": "string"
      }
    },
    "required": [
      "tabIdentifier",
      "filePath"
    ]
  },
  "GetBuildLog": {
    "type": "object",
    "properties": {
      "glob": {
        "description": "Glob to filter the returned build log entries. Will match against the 'path' field of any emitted issues, as well as against the location of any build task.",
        "type": "string"
      },
      "pattern": {
        "description": "Regex to filter the returned build log entries. Will match against the 'message' field of any emitted issues, as well as the task description, command line, and console output of any build tasks.",
        "type": "string"
      },
      "severity": {
        "description": "Limit the output of build log entries to those that emitted issues of the specified severity or higher. Valid values in order of decreasing severity are 'error', 'warning', 'remark'. Defaults to 'error'.",
        "enum": [
          "remark",
          "warning",
          "error"
        ],
        "type": "string"
      },
      "tabIdentifier": {
        "description": "The workspace tab identifier",
        "type": "string"
      }
    },
    "required": [
      "tabIdentifier"
    ]
  },
  "XcodeListWindows": {
    "type": "object",
    "properties": {},
    "required": []
  },
  "BuildProject": {
    "type": "object",
    "properties": {
      "tabIdentifier": {
        "description": "The workspace tab identifier",
        "type": "string"
      }
    },
    "required": [
      "tabIdentifier"
    ]
  },
  "RunAllTests": {
    "type": "object",
    "properties": {
      "tabIdentifier": {
        "description": "The workspace tab identifier",
        "type": "string"
      }
    },
    "required": [
      "tabIdentifier"
    ]
  },
  "XcodeWrite": {
    "type": "object",
    "properties": {
      "content": {
        "description": "REQUIRED: The content to write to the file",
        "type": "string"
      },
      "filePath": {
        "description": "REQUIRED: The path to the file within the Xcode project organization (e.g., 'ProjectName/Sources/MyFile.swift')",
        "type": "string"
      },
      "tabIdentifier": {
        "description": "The workspace tab identifier (required)",
        "type": "string"
      }
    },
    "required": [
      "tabIdentifier",
      "filePath",
      "content"
    ]
  },
  "XcodeGrep": {
    "type": "object",
    "properties": {
      "glob": {
        "description": "Only search files matching this pattern",
        "type": "string"
      },
      "headLimit": {
        "description": "Stop after N results",
        "type": "integer"
      },
      "ignoreCase": {
        "description": "Ignore case when matching",
        "type": "boolean"
      },
      "linesAfter": {
        "description": "Show N lines after each match for context",
        "type": "integer"
      },
      "linesBefore": {
        "description": "Show N lines before each match for context",
        "type": "integer"
      },
      "linesContext": {
        "description": "Show N lines both before and after each match",
        "type": "integer"
      },
      "multiline": {
        "description": "Allow patterns to span multiple lines",
        "type": "boolean"
      },
      "outputMode": {
        "description": "What to return: content, files_with_matches, or count (default: files_with_matches)",
        "enum": [
          "content",
          "filesWithMatches",
          "count"
        ],
        "type": "string"
      },
      "path": {
        "description": "Where to search - file or directory in project (defaults to root)",
        "type": "string"
      },
      "pattern": {
        "description": "Text to search for using regex. REQUIRED: Must include a 'pattern' argument - this tool will fail without it.",
        "type": "string"
      },
      "showLineNumbers": {
        "description": "Show line numbers with results (content mode only)",
        "type": "boolean"
      },
      "tabIdentifier": {
        "description": "The workspace tab identifier",
        "type": "string"
      },
      "type": {
        "description": "Shortcut for common file types (swift, js, py, etc.)",
        "type": "string"
      }
    },
    "required": [
      "tabIdentifier",
      "pattern"
    ]
  },
  "XcodeLS": {
    "type": "object",
    "properties": {
      "ignore": {
        "description": "Skip files/folders matching these patterns",
        "items": {
          "type": "string"
        },
        "type": "array"
      },
      "path": {
        "description": "The project path to browse (e.g., 'ProjectName/Sources/')",
        "type": "string"
      },
      "recursive": {
        "description": "Recursively list all files (truncated to 100 lines). Default: true",
        "type": "boolean"
      },
      "tabIdentifier": {
        "description": "The workspace tab identifier",
        "type": "string"
      }
    },
    "required": [
      "tabIdentifier",
      "path"
    ]
  },
  "DocumentationSearch": {
    "type": "object",
    "properties": {
      "frameworks": {
        "description": "Framework(s) to search in. Searches all frameworks if not specified.",
        "items": {
          "type": "string"
        },
        "type": "array"
      },
      "query": {
        "description": "The search query",
        "type": "string"
      }
    },
    "required": [
      "query"
    ]
  },
  "GetTestList": {
    "type": "object",
    "properties": {
      "tabIdentifier": {
        "description": "The workspace tab identifier",
        "type": "string"
      }
    },
    "required": [
      "tabIdentifier"
    ]
  },
  "XcodeGlob": {
    "type": "object",
    "properties": {
      "path": {
        "description": "Which project directory to search in (optional, defaults to root)",
        "type": "string"
      },
      "pattern": {
        "description": "File matching pattern using wildcards (* ** ? [abc] {swift,m}). Examples: '*.swift', '**/*.json', 'src/**/*.{swift,m}'. Defaults to '**/*' if not provided.",
        "type": "string"
      },
      "tabIdentifier": {
        "description": "The workspace tab identifier",
        "type": "string"
      }
    },
    "required": [
      "tabIdentifier"
    ]
  },
  "XcodeListNavigatorIssues": {
    "type": "object",
    "properties": {
      "glob": {
        "description": "Glob to filter the returned issues. Will match against the 'path' field.",
        "type": "string"
      },
      "pattern": {
        "description": "Regex to filter the returned issues. Will match against the 'message' field.",
        "type": "string"
      },
      "severity": {
        "description": "Limit the returned issues to those that have the specified severity or higher. Valid values in order of decreasing severity are 'error', 'warning', 'remark'. Defaults to 'error'.",
        "type": "string"
      },
      "tabIdentifier": {
        "description": "The workspace tab identifier",
        "type": "string"
      }
    },
    "required": [
      "tabIdentifier"
    ]
  },
  "XcodeMakeDir": {
    "type": "object",
    "properties": {
      "directoryPath": {
        "description": "Project navigator relative path for the directory to create",
        "type": "string"
      },
      "tabIdentifier": {
        "description": "The workspace tab identifier",
        "type": "string"
      }
    },
    "required": [
      "tabIdentifier",
      "directoryPath"
    ]
  },
  "ExecuteSnippet": {
    "type": "object",
    "properties": {
      "codeSnippet": {
        "description": "The code snippet that should be executed in the context of the specified file.",
        "type": "string"
      },
      "sourceFilePath": {
        "description": "The path to a Swift source file within the Xcode project organization (e.g., 'ProjectName/Sources/MyFile.swift') whose context the code snippet will have access to (including `fileprivate` declarations).",
        "type": "string"
      },
      "tabIdentifier": {
        "description": "The workspace tab identifier.",
        "type": "string"
      },
      "timeout": {
        "description": "The time in seconds to wait for the execution of the snippet to complete. Defaults to 120 seconds.",
        "type": "integer"
      }
    },
    "required": [
      "tabIdentifier",
      "codeSnippet",
      "sourceFilePath"
    ]
  },
  "RenderPreview": {
    "type": "object",
    "properties": {
      "previewDefinitionIndexInFile": {
        "description": "The zero based index of the #Preview macro or PreviewProvider struct definition in the source file counting from the top. Defaults to 0, i.e. the first one.",
        "type": "integer"
      },
      "sourceFilePath": {
        "description": "The path to the file within the Xcode project organization (e.g., 'ProjectName/Sources/MyFile.swift')",
        "type": "string"
      },
      "tabIdentifier": {
        "description": "The workspace tab identifier",
        "type": "string"
      },
      "timeout": {
        "description": "The time in seconds to wait for the rendering of the preview to complete. Defaults to 120 seconds.",
        "type": "integer"
      }
    },
    "required": [
      "tabIdentifier",
      "sourceFilePath"
    ]
  }
} as const;
const embeddedName = "mcpbridge";
const embeddedDescription = "xcode-tools";
const generatorInfo = "Generated by xcode-mcp@1.0.0 â€” https://github.com/steipete/mcporter";
const generatorTools = [
  {
    "name": "XcodeUpdate",
    "description": "Edits files in the Xcode project by replacing text content. Works on Xcode project structure paths, not filesystem paths. IMPORTANT: The tool will fail if filePath, oldString, or newString parameters are missing.",
    "usage": "XcodeUpdate --file-path <file-path> --new-string <new-string> --old-string <old-string> [--replace-all <replace-all:true|false>] --tab-identifier <tab-identifier> [--raw <json>]",
    "flags": "--file-path <file-path> --new-string <new-string> --old-string <old-string> [--replace-all <replace-all:true|false>] --tab-identifier <tab-identifier> [--raw <json>]"
  },
  {
    "name": "XcodeMV",
    "description": "Moves or renames files and directories in the project navigator with support for filesystem operations.",
    "usage": "XcodeMV --destination-path <destination-path> [--operation <operation:move|copy>] [--overwrite-existing <overwrite-existing:true|false>] --source-path <source-path> --tab-identifier <tab-identifier> [--raw <json>]",
    "flags": "--destination-path <destination-path> [--operation <operation:move|copy>] [--overwrite-existing <overwrite-existing:true|false>] --source-path <source-path> --tab-identifier <tab-identifier> [--raw <json>]"
  },
  {
    "name": "XcodeRead",
    "description": "Reads the contents of a file within the Xcode project organization. Returns content in cat -n format with line numbers. Supports reading up to 600 lines by default with optional offset and limit parameters for large files.",
    "usage": "XcodeRead --file-path <file-path> [--limit <limit:number>] [--offset <offset:number>] --tab-identifier <tab-identifier> [--raw <json>]",
    "flags": "--file-path <file-path> [--limit <limit:number>] [--offset <offset:number>] --tab-identifier <tab-identifier> [--raw <json>]"
  },
  {
    "name": "RunSomeTests",
    "description": "Runs specific tests using the active scheme's active test plan",
    "usage": "RunSomeTests --tab-identifier <tab-identifier> --tests <tests:value1,value2> [--raw <json>]",
    "flags": "--tab-identifier <tab-identifier> --tests <tests:value1,value2> [--raw <json>]"
  },
  {
    "name": "XcodeRM",
    "description": "Removes files and directories from the Xcode project structure and optionally deletes the underlying files from the filesystem.",
    "usage": "XcodeRM [--delete-files <delete-files:true|false>] --path <path> [--recursive <recursive:true|false>] --tab-identifier <tab-identifier> [--raw <json>]",
    "flags": "[--delete-files <delete-files:true|false>] --path <path> [--recursive <recursive:true|false>] --tab-identifier <tab-identifier> [--raw <json>]"
  },
  {
    "name": "XcodeRefreshCodeIssuesInFile",
    "description": "Retrieves current compiler diagnostics (errors, warnings, notes) for a file in the Xcode project. Returns formatted diagnostic information including severity levels and messages.",
    "usage": "XcodeRefreshCodeIssuesInFile --file-path <file-path> --tab-identifier <tab-identifier> [--raw <json>]",
    "flags": "--file-path <file-path> --tab-identifier <tab-identifier> [--raw <json>]"
  },
  {
    "name": "GetBuildLog",
    "description": "Gets the log of the current or most recently finished build. You can choose which build log entries to include by specifying the severity of any issues emitted by the build task represented by the entry. You can also filter by message regex pattern or file glob pattern. The response also indicates whether the build is currently in progress.",
    "usage": "GetBuildLog [--glob <glob>] [--pattern <pattern>] [--severity <severity:remark|warning|error>] --tab-identifier <tab-identifier> [--raw <json>]",
    "flags": "[--glob <glob>] [--pattern <pattern>] [--severity <severity:remark|warning|error>] --tab-identifier <tab-identifier> [--raw <json>]"
  },
  {
    "name": "XcodeListWindows",
    "description": "Lists the current Xcode windows and their workspace information",
    "usage": "XcodeListWindows [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "BuildProject",
    "description": "Builds an Xcode project and waits until the build completes.",
    "usage": "BuildProject --tab-identifier <tab-identifier> [--raw <json>]",
    "flags": "--tab-identifier <tab-identifier> [--raw <json>]"
  },
  {
    "name": "RunAllTests",
    "description": "Runs all tests from the active scheme's active test plan",
    "usage": "RunAllTests --tab-identifier <tab-identifier> [--raw <json>]",
    "flags": "--tab-identifier <tab-identifier> [--raw <json>]"
  },
  {
    "name": "XcodeWrite",
    "description": "Creates or overwrites files with content in the Xcode project. Works on Xcode project structure paths, not filesystem paths. Automatically adds new files to the project structure. Both filePath and content parameters are required.",
    "usage": "XcodeWrite --content <content> --file-path <file-path> --tab-identifier <tab-identifier> [--raw <json>]",
    "flags": "--content <content> --file-path <file-path> --tab-identifier <tab-identifier> [--raw <json>]"
  },
  {
    "name": "XcodeGrep",
    "description": "Searches for text patterns in files within the Xcode project structure using regex. Works on Xcode project organization, not filesystem structure. CRITICAL: Must include a 'pattern' argument - this tool will fail without it.",
    "usage": "XcodeGrep [--glob <glob>] [--head-limit <head-limit:number>] [--ignore-case <ignore-case:true|false>] --pattern <pattern> --tab-identifier <tab-identifier> [--raw <json>]",
    "flags": "[--glob <glob>] [--head-limit <head-limit:number>] [--ignore-case <ignore-case:true|false>] --pattern <pattern> --tab-identifier <tab-identifier> [--raw <json>]"
  },
  {
    "name": "XcodeLS",
    "description": "Lists files and directories in the Xcode project structure at the specified path. Works on Xcode project organization, not filesystem structure.",
    "usage": "XcodeLS [--ignore <ignore:value1,value2>] --path <path> [--recursive <recursive:true|false>] --tab-identifier <tab-identifier> [--raw <json>]",
    "flags": "[--ignore <ignore:value1,value2>] --path <path> [--recursive <recursive:true|false>] --tab-identifier <tab-identifier> [--raw <json>]"
  },
  {
    "name": "DocumentationSearch",
    "description": "Searches Apple Developer Documentation using semantic matching.",
    "usage": "DocumentationSearch [--frameworks <frameworks:value1,value2>] --query <query> [--raw <json>]",
    "flags": "[--frameworks <frameworks:value1,value2>] --query <query> [--raw <json>]"
  },
  {
    "name": "GetTestList",
    "description": "Gets all available tests from the active scheme's active test plan. Results are limited to 100 tests. The complete list is written to fullTestListPath in grep-friendly format. Use grep with keys like TEST_TARGET, TEST_IDENTIFIER, or TEST_FILE_PATH to find specific tests.",
    "usage": "GetTestList --tab-identifier <tab-identifier> [--raw <json>]",
    "flags": "--tab-identifier <tab-identifier> [--raw <json>]"
  },
  {
    "name": "XcodeGlob",
    "description": "Finds files in the Xcode project structure matching wildcard patterns. Works on Xcode project organization, not filesystem structure. Example patterns: '*.swift', '**/*.json', 'src/**/*.{swift,m}'. If no pattern is provided, defaults to '**/*' (all files).",
    "usage": "XcodeGlob [--path <path>] [--pattern <pattern>] --tab-identifier <tab-identifier> [--raw <json>]",
    "flags": "[--path <path>] [--pattern <pattern>] --tab-identifier <tab-identifier> [--raw <json>]"
  },
  {
    "name": "XcodeListNavigatorIssues",
    "description": "Lists the currently known issues shown Xcode's Issue Navigator UI in the workspace. These issues include those that have been discovered since the last build, and also issues like package resolution problems and workspace configuration issues. You can filter the issues to include by file name, glob, or severity. Use this tool when you want to list all the users the user can see in the workspace UI.",
    "usage": "XcodeListNavigatorIssues [--glob <glob>] [--pattern <pattern>] [--severity <severity>] --tab-identifier <tab-identifier> [--raw <json>]",
    "flags": "[--glob <glob>] [--pattern <pattern>] [--severity <severity>] --tab-identifier <tab-identifier> [--raw <json>]"
  },
  {
    "name": "XcodeMakeDir",
    "description": "Creates directories and groups in the Xcode project structure.",
    "usage": "XcodeMakeDir --directory-path <directory-path> --tab-identifier <tab-identifier> [--raw <json>]",
    "flags": "--directory-path <directory-path> --tab-identifier <tab-identifier> [--raw <json>]"
  },
  {
    "name": "ExecuteSnippet",
    "description": "Builds and runs a snippet of code in the context of a specific file and waits until results are available. This tool is available for source files in targets that build applications, frameworks, libraries, or command line executables. The output consists of the console output generated by the `print` statements contained in the provided snippet.",
    "usage": "ExecuteSnippet --code-snippet <code-snippet> --source-file-path <source-file-path> --tab-identifier <tab-identifier> [--timeout <timeout:number>] [--raw <json>]",
    "flags": "--code-snippet <code-snippet> --source-file-path <source-file-path> --tab-identifier <tab-identifier> [--timeout <timeout:number>] [--raw <json>]"
  },
  {
    "name": "RenderPreview",
    "description": "Builds and renders a Preview and waits until a snapshot of the resulting UI is available.",
    "usage": "RenderPreview [--preview-definition-index-in-file <preview-definition-index-in-file:number>] --source-file-path <source-file-path> --tab-identifier <tab-identifier> [--timeout <timeout:number>] [--raw <json>]",
    "flags": "[--preview-definition-index-in-file <preview-definition-index-in-file:number>] --source-file-path <source-file-path> --tab-identifier <tab-identifier> [--timeout <timeout:number>] [--raw <json>]"
  }
] as const;
const embeddedMetadata = {
  "schemaVersion": 1,
  "generatedAt": "2026-02-27T19:58:04.864Z",
  "generator": {
    "name": "xcode-mcp",
    "version": "1.0.0"
  },
  "server": {
    "name": "mcpbridge",
    "source": {
      "kind": "local",
      "path": "<adhoc>"
    },
    "definition": {
      "name": "mcpbridge",
      "description": "xcode-tools",
      "command": {
        "kind": "stdio",
        "command": "xcrun",
        "args": [
          "mcpbridge"
        ]
      }
    }
  },
  "artifact": {
    "path": "",
    "kind": "template"
  },
  "invocation": {
    "serverRef": "{\"name\":\"mcpbridge\",\"description\":\"xcode-tools\",\"command\":{\"kind\":\"stdio\",\"command\":\"xcrun\",\"args\":[\"mcpbridge\"]},\"source\":{\"kind\":\"local\",\"path\":\"<adhoc>\"}}",
    "configPath": "<adhoc>",
    "runtime": "node",
    "bundler": "rolldown",
    "outputPath": "./src/mcpbridge.ts",
    "timeoutMs": 30000,
    "minify": false
  }
} as const;
const artifactKind = determineArtifactKind();
const program = new Command();
program.name(embeddedName);
program.description(embeddedDescription);
program.option('-t, --timeout <ms>', 'Call timeout in milliseconds', (value) => parseInt(value, 10), 30000);
program.option('-o, --output <format>', 'Output format: text|markdown|json|raw', 'text');
const commandSignatures: Record<string, string> = {
  "XcodeUpdate": "function XcodeUpdate(filePath: string, newString: string, oldString: string, replaceAll?: boolean, tabIdentifier: string): object;",
  "XcodeMV": "function XcodeMV(destinationPath: string, operation?: \"move\" | \"copy\", overwriteExisting?: boolean, sourcePath: string, tabIdentifier: string): object;",
  "XcodeRead": "function XcodeRead(filePath: string, limit?: number, offset?: number, tabIdentifier: string): object;",
  "RunSomeTests": "function RunSomeTests(tabIdentifier: string, tests: string[]): object;",
  "XcodeRM": "function XcodeRM(deleteFiles?: boolean, path: string, recursive?: boolean, tabIdentifier: string): object;",
  "XcodeRefreshCodeIssuesInFile": "function XcodeRefreshCodeIssuesInFile(filePath: string, tabIdentifier: string): object;",
  "GetBuildLog": "function GetBuildLog(glob?: string, pattern?: string, severity?: \"remark\" | \"warning\" | \"error\", tabIdentifier: string): object;",
  "XcodeListWindows": "function XcodeListWindows(): object;",
  "BuildProject": "function BuildProject(tabIdentifier: string): object;",
  "RunAllTests": "function RunAllTests(tabIdentifier: string): object;",
  "XcodeWrite": "function XcodeWrite(content: string, filePath: string, tabIdentifier: string): object;",
  "XcodeGrep": "function XcodeGrep(glob?: string, headLimit?: number, ignoreCase?: boolean, pattern: string, tabIdentifier: string): object;",
  "XcodeLS": "function XcodeLS(ignore?: string[], path: string, recursive?: boolean, tabIdentifier: string): object;",
  "DocumentationSearch": "function DocumentationSearch(frameworks?: string[], query: string): object;",
  "GetTestList": "function GetTestList(tabIdentifier: string): object;",
  "XcodeGlob": "function XcodeGlob(path?: string, pattern?: string, tabIdentifier: string): object;",
  "XcodeListNavigatorIssues": "function XcodeListNavigatorIssues(glob?: string, pattern?: string, severity?: string, tabIdentifier: string): object;",
  "XcodeMakeDir": "function XcodeMakeDir(directoryPath: string, tabIdentifier: string): object;",
  "ExecuteSnippet": "function ExecuteSnippet(codeSnippet: string, sourceFilePath: string, tabIdentifier: string, timeout?: number): object;",
  "RenderPreview": "function RenderPreview(previewDefinitionIndexInFile?: number, sourceFilePath: string, tabIdentifier: string, timeout?: number): object;"
};
program.configureHelp({
	commandTerm(cmd) {
		const term = cmd.name();
		return commandSignatures[term] ?? cmd.name();
	},
});
program.showSuggestionAfterError(true);

program
	.command("XcodeUpdate")
	.summary("XcodeUpdate --file-path <file-path> --new-string <new-string> --old-string <old-string> [--replace-all <replace-all:true|false>] --tab-identifier <tab-identifier> [--raw <json>]")
	.description("Edits files in the Xcode project by replacing text content. Works on Xcode project structure paths, not filesystem paths. IMPORTANT: The tool will fail if filePath, oldString, or newString parameters are missing.")
	.usage("--file-path <file-path> --new-string <new-string> --old-string <old-string> [--replace-all <replace-all:true|false>] --tab-identifier <tab-identifier> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--file-path <file-path>", "REQUIRED: The path to the file to modify within the Xcode project organization (e.g., 'ProjectName/Sources/MyFile.swift') (example: /path/to/file.md)")
	.requiredOption("--new-string <new-string>", "REQUIRED: The text to replace it with, must be different from oldString")
	.requiredOption("--old-string <old-string>", "REQUIRED: The text to replace")
	.option("--replace-all <replace-all:true|false>", "Replace all occurrences of oldString (default false) (example: true)", (value) => value !== 'false')
	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (example: example-id)")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.filePath !== undefined) args.filePath = cmdOpts.filePath;
		if (cmdOpts.newString !== undefined) args.newString = cmdOpts.newString;
		if (cmdOpts.oldString !== undefined) args.oldString = cmdOpts.oldString;
		if (cmdOpts.replaceAll !== undefined) args.replaceAll = cmdOpts.replaceAll;
		if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
			const call = (proxy.xcodeUpdate as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.XcodeUpdate(filePath: \"/path/to/file.md\", newStrin, ...)");

program
	.command("XcodeMV")
	.summary("XcodeMV --destination-path <destination-path> [--operation <operation:move|copy>] [--overwrite-existing <overwrite-existing:true|false>] --source-path <source-path> --tab-identifier <tab-identifier> [--raw <json>]")
	.description("Moves or renames files and directories in the project navigator with support for filesystem operations.")
	.usage("--destination-path <destination-path> [--operation <operation:move|copy>] [--overwrite-existing <overwrite-existing:true|false>] --source-path <source-path> --tab-identifier <tab-identifier> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--destination-path <destination-path>", "Project navigator relative path for the destination (for move) or new name (for rename) (example: /path/to/file.md)")
	.option("--operation <operation:move|copy>", "The type of move operation to perform (choices: move, copy; example: move)")
	.option("--overwrite-existing <overwrite-existing:true|false>", "Whether to overwrite existing files at the destination (example: true)", (value) => value !== 'false')
	.requiredOption("--source-path <source-path>", "Project navigator relative path of the source item to move/rename (example: /path/to/file.md)")
	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (example: example-id)")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.destinationPath !== undefined) args.destinationPath = cmdOpts.destinationPath;
		if (cmdOpts.operation !== undefined) args.operation = cmdOpts.operation;
		if (cmdOpts.overwriteExisting !== undefined) args.overwriteExisting = cmdOpts.overwriteExisting;
		if (cmdOpts.sourcePath !== undefined) args.sourcePath = cmdOpts.sourcePath;
		if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
			const call = (proxy.xcodeMV as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.XcodeMV(destinationPath: \"/path/to/file.md\", opera, ...)");

program
	.command("XcodeRead")
	.summary("XcodeRead --file-path <file-path> [--limit <limit:number>] [--offset <offset:number>] --tab-identifier <tab-identifier> [--raw <json>]")
	.description("Reads the contents of a file within the Xcode project organization. Returns content in cat -n format with line numbers. Supports reading up to 600 lines by default with optional offset and limit parameters for large files.")
	.usage("--file-path <file-path> [--limit <limit:number>] [--offset <offset:number>] --tab-identifier <tab-identifier> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--file-path <file-path>", "The path to the file within the Xcode project organization (e.g., 'ProjectName/Sources/MyFile.swift') (example: /path/to/file.md)")
	.option("--limit <limit:number>", "The number of lines to read (only provide if the file is too large to read at once) (example: 1)", (value) => parseFloat(value))
	.option("--offset <offset:number>", "The line number to start reading from (only provide if the file is too large to read at once) (example: 1)", (value) => parseFloat(value))
	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (example: example-id)")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.filePath !== undefined) args.filePath = cmdOpts.filePath;
		if (cmdOpts.limit !== undefined) args.limit = cmdOpts.limit;
		if (cmdOpts.offset !== undefined) args.offset = cmdOpts.offset;
		if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
			const call = (proxy.xcodeRead as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.XcodeRead(filePath: \"/path/to/file.md\", limit: 1, ...)");

program
	.command("RunSomeTests")
	.summary("RunSomeTests --tab-identifier <tab-identifier> --tests <tests:value1,value2> [--raw <json>]")
	.description("Runs specific tests using the active scheme's active test plan")
	.usage("--tab-identifier <tab-identifier> --tests <tests:value1,value2> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (example: example-id)")
	.requiredOption("--tests <tests:value1,value2>", "Array of test specifiers to run. Each specifier contains 'targetName' and 'testIdentifier' fields. Use GetTestList action to discover available tests and their identifiers, then extract the 'targetName' and 'identifier' fields from the TestActionInfo results to construct TestActionSpecifier objects. (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
		if (cmdOpts.tests !== undefined) args.tests = cmdOpts.tests;
			const call = (proxy.runSomeTests as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.RunSomeTests(tabIdentifier: \"example-id\", tests: [, ...)");

program
	.command("XcodeRM")
	.summary("XcodeRM [--delete-files <delete-files:true|false>] --path <path> [--recursive <recursive:true|false>] --tab-identifier <tab-identifier> [--raw <json>]")
	.description("Removes files and directories from the Xcode project structure and optionally deletes the underlying files from the filesystem.")
	.usage("[--delete-files <delete-files:true|false>] --path <path> [--recursive <recursive:true|false>] --tab-identifier <tab-identifier> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--delete-files <delete-files:true|false>", "Also move the underlying files to Trash (defaults to true) (example: true)", (value) => value !== 'false')
	.requiredOption("--path <path>", "The project path to remove (e.g., 'ProjectName/Sources/MyFile.swift') (example: /path/to/file.md)")
	.option("--recursive <recursive:true|false>", "Remove directories and their contents recursively (example: true)", (value) => value !== 'false')
	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (example: example-id)")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.deleteFiles !== undefined) args.deleteFiles = cmdOpts.deleteFiles;
		if (cmdOpts.path !== undefined) args.path = cmdOpts.path;
		if (cmdOpts.recursive !== undefined) args.recursive = cmdOpts.recursive;
		if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
			const call = (proxy.xcodeRM as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.XcodeRM(deleteFiles: true, path: \"/path/to/file.md, ...)");

program
	.command("XcodeRefreshCodeIssuesInFile")
	.summary("XcodeRefreshCodeIssuesInFile --file-path <file-path> --tab-identifier <tab-identifier> [--raw <json>]")
	.description("Retrieves current compiler diagnostics (errors, warnings, notes) for a file in the Xcode project. Returns formatted diagnostic information including severity levels and messages.")
	.usage("--file-path <file-path> --tab-identifier <tab-identifier> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--file-path <file-path>", "The path to the file within the Xcode project organization (e.g., 'ProjectName/Sources/MyFile.swift') (example: /path/to/file.md)")
	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (example: example-id)")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.filePath !== undefined) args.filePath = cmdOpts.filePath;
		if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
			const call = (proxy.xcodeRefreshCodeIssuesInFile as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.XcodeRefreshCodeIssuesInFile(filePath: \"/path/to/f, ...)");

program
	.command("GetBuildLog")
	.summary("GetBuildLog [--glob <glob>] [--pattern <pattern>] [--severity <severity:remark|warning|error>] --tab-identifier <tab-identifier> [--raw <json>]")
	.description("Gets the log of the current or most recently finished build. You can choose which build log entries to include by specifying the severity of any issues emitted by the build task represented by the entry. You can also filter by message regex pattern or file glob pattern. The response also indicates whether the build is currently in progress.")
	.usage("[--glob <glob>] [--pattern <pattern>] [--severity <severity:remark|warning|error>] --tab-identifier <tab-identifier> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--glob <glob>", "Glob to filter the returned build log entries. Will match against the 'path' field of any emitted issues, as well as against the location of any build task.")
	.option("--pattern <pattern>", "Regex to filter the returned build log entries. Will match against the 'message' field of any emitted issues, as well as the task description, command line, and console output of any build tasks.")
	.option("--severity <severity:remark|warning|error>", "Limit the output of build log entries to those that emitted issues of the specified severity or higher. Valid values in order of decreasing severity are 'error', 'warning', 'remark'. Defaults to 'error'. (choices: remark, warning, error; example: remark)")
	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (example: example-id)")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.glob !== undefined) args.glob = cmdOpts.glob;
		if (cmdOpts.pattern !== undefined) args.pattern = cmdOpts.pattern;
		if (cmdOpts.severity !== undefined) args.severity = cmdOpts.severity;
		if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
			const call = (proxy.getBuildLog as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.GetBuildLog(severity: \"remark\", tabIdentifier: \"ex, ...)");

program
	.command("XcodeListWindows")
	.summary("XcodeListWindows [--raw <json>]")
	.description("Lists the current Xcode windows and their workspace information")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.xcodeListWindows as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.XcodeListWindows()");

program
	.command("BuildProject")
	.summary("BuildProject --tab-identifier <tab-identifier> [--raw <json>]")
	.description("Builds an Xcode project and waits until the build completes.")
	.usage("--tab-identifier <tab-identifier> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (example: example-id)")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
			const call = (proxy.buildProject as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.BuildProject(tabIdentifier: \"example-id\")");

program
	.command("RunAllTests")
	.summary("RunAllTests --tab-identifier <tab-identifier> [--raw <json>]")
	.description("Runs all tests from the active scheme's active test plan")
	.usage("--tab-identifier <tab-identifier> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (example: example-id)")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
			const call = (proxy.runAllTests as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.RunAllTests(tabIdentifier: \"example-id\")");

program
	.command("XcodeWrite")
	.summary("XcodeWrite --content <content> --file-path <file-path> --tab-identifier <tab-identifier> [--raw <json>]")
	.description("Creates or overwrites files with content in the Xcode project. Works on Xcode project structure paths, not filesystem paths. Automatically adds new files to the project structure. Both filePath and content parameters are required.")
	.usage("--content <content> --file-path <file-path> --tab-identifier <tab-identifier> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--content <content>", "REQUIRED: The content to write to the file")
	.requiredOption("--file-path <file-path>", "REQUIRED: The path to the file within the Xcode project organization (e.g., 'ProjectName/Sources/MyFile.swift') (example: /path/to/file.md)")
	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (required) (example: example-id)")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.content !== undefined) args.content = cmdOpts.content;
		if (cmdOpts.filePath !== undefined) args.filePath = cmdOpts.filePath;
		if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
			const call = (proxy.xcodeWrite as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.XcodeWrite(content: \"value\", filePath: \"/path/to/f, ...)");

program
	.command("XcodeGrep")
	.summary("XcodeGrep [--glob <glob>] [--head-limit <head-limit:number>] [--ignore-case <ignore-case:true|false>] --pattern <pattern> --tab-identifier <tab-identifier> [--raw <json>]")
	.description("Searches for text patterns in files within the Xcode project structure using regex. Works on Xcode project organization, not filesystem structure. CRITICAL: Must include a 'pattern' argument - this tool will fail without it.")
	.usage("[--glob <glob>] [--head-limit <head-limit:number>] [--ignore-case <ignore-case:true|false>] --pattern <pattern> --tab-identifier <tab-identifier> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--glob <glob>", "Only search files matching this pattern")
	.option("--head-limit <head-limit:number>", "Stop after N results (example: 1)", (value) => parseFloat(value))
	.option("--ignore-case <ignore-case:true|false>", "Ignore case when matching (example: true)", (value) => value !== 'false')
	.option("--lines-after <lines-after:number>", "Show N lines after each match for context (example: 1)", (value) => parseFloat(value))
	.option("--lines-before <lines-before:number>", "Show N lines before each match for context (example: 1)", (value) => parseFloat(value))
	.option("--lines-context <lines-context:number>", "Show N lines both before and after each match (example: 1)", (value) => parseFloat(value))
	.option("--multiline <multiline:true|false>", "Allow patterns to span multiple lines (example: true)", (value) => value !== 'false')
	.option("--output-mode <output-mode:content|filesWithMatches|count>", "What to return: content, files_with_matches, or count (default: files_with_matches) (choices: content, filesWithMatches, count; example: content)")
	.option("--path <path>", "Where to search - file or directory in project (defaults to root) (example: /path/to/file.md)")
	.requiredOption("--pattern <pattern>", "Text to search for using regex. REQUIRED: Must include a 'pattern' argument - this tool will fail without it.")
	.option("--show-line-numbers <show-line-numbers:true|false>", "Show line numbers with results (content mode only) (example: true)", (value) => value !== 'false')
	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (example: example-id)")
	.option("--type <type>", "Shortcut for common file types (swift, js, py, etc.)")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.glob !== undefined) args.glob = cmdOpts.glob;
		if (cmdOpts.headLimit !== undefined) args.headLimit = cmdOpts.headLimit;
		if (cmdOpts.ignoreCase !== undefined) args.ignoreCase = cmdOpts.ignoreCase;
		if (cmdOpts.linesAfter !== undefined) args.linesAfter = cmdOpts.linesAfter;
		if (cmdOpts.linesBefore !== undefined) args.linesBefore = cmdOpts.linesBefore;
		if (cmdOpts.linesContext !== undefined) args.linesContext = cmdOpts.linesContext;
		if (cmdOpts.multiline !== undefined) args.multiline = cmdOpts.multiline;
		if (cmdOpts.outputMode !== undefined) args.outputMode = cmdOpts.outputMode;
		if (cmdOpts.path !== undefined) args.path = cmdOpts.path;
		if (cmdOpts.pattern !== undefined) args.pattern = cmdOpts.pattern;
		if (cmdOpts.showLineNumbers !== undefined) args.showLineNumbers = cmdOpts.showLineNumbers;
		if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
		if (cmdOpts.type !== undefined) args.type = cmdOpts.type;
			const call = (proxy.xcodeGrep as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.XcodeGrep(headLimit: 1, ignoreCase: true, pattern:, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (8): linesAfter, linesBefore, linesContext, multiline, outputMode, ..." + '\n');

program
	.command("XcodeLS")
	.summary("XcodeLS [--ignore <ignore:value1,value2>] --path <path> [--recursive <recursive:true|false>] --tab-identifier <tab-identifier> [--raw <json>]")
	.description("Lists files and directories in the Xcode project structure at the specified path. Works on Xcode project organization, not filesystem structure.")
	.usage("[--ignore <ignore:value1,value2>] --path <path> [--recursive <recursive:true|false>] --tab-identifier <tab-identifier> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--ignore <ignore:value1,value2>", "Skip files/folders matching these patterns (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.requiredOption("--path <path>", "The project path to browse (e.g., 'ProjectName/Sources/') (example: /path/to/file.md)")
	.option("--recursive <recursive:true|false>", "Recursively list all files (truncated to 100 lines). Default: true (example: true)", (value) => value !== 'false')
	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (example: example-id)")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.ignore !== undefined) args.ignore = cmdOpts.ignore;
		if (cmdOpts.path !== undefined) args.path = cmdOpts.path;
		if (cmdOpts.recursive !== undefined) args.recursive = cmdOpts.recursive;
		if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
			const call = (proxy.xcodeLS as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.XcodeLS(ignore: [\"value1\", \"value2\"], path: \"/path, ...)");

program
	.command("DocumentationSearch")
	.summary("DocumentationSearch [--frameworks <frameworks:value1,value2>] --query <query> [--raw <json>]")
	.description("Searches Apple Developer Documentation using semantic matching.")
	.usage("[--frameworks <frameworks:value1,value2>] --query <query> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--frameworks <frameworks:value1,value2>", "Framework(s) to search in. Searches all frameworks if not specified. (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.requiredOption("--query <query>", "The search query")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.frameworks !== undefined) args.frameworks = cmdOpts.frameworks;
		if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
			const call = (proxy.documentationSearch as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.DocumentationSearch(frameworks: [\"value1\", \"value2, ...)");

program
	.command("GetTestList")
	.summary("GetTestList --tab-identifier <tab-identifier> [--raw <json>]")
	.description("Gets all available tests from the active scheme's active test plan. Results are limited to 100 tests. The complete list is written to fullTestListPath in grep-friendly format. Use grep with keys like TEST_TARGET, TEST_IDENTIFIER, or TEST_FILE_PATH to find specific tests.")
	.usage("--tab-identifier <tab-identifier> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (example: example-id)")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
			const call = (proxy.getTestList as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.GetTestList(tabIdentifier: \"example-id\")");

program
	.command("XcodeGlob")
	.summary("XcodeGlob [--path <path>] [--pattern <pattern>] --tab-identifier <tab-identifier> [--raw <json>]")
	.description("Finds files in the Xcode project structure matching wildcard patterns. Works on Xcode project organization, not filesystem structure. Example patterns: '*.swift', '**/*.json', 'src/**/*.{swift,m}'. If no pattern is provided, defaults to '**/*' (all files).")
	.usage("[--path <path>] [--pattern <pattern>] --tab-identifier <tab-identifier> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--path <path>", "Which project directory to search in (optional, defaults to root) (example: /path/to/file.md)")
	.option("--pattern <pattern>", "File matching pattern using wildcards (* ** ? [abc] {swift,m}). Examples: '*.swift', '**/*.json', 'src/**/*.{swift,m}'. Defaults to '**/*' if not provided.")
	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (example: example-id)")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.path !== undefined) args.path = cmdOpts.path;
		if (cmdOpts.pattern !== undefined) args.pattern = cmdOpts.pattern;
		if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
			const call = (proxy.xcodeGlob as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.XcodeGlob(path: \"/path/to/file.md\", tabIdentifier:, ...)");

program
	.command("XcodeListNavigatorIssues")
	.summary("XcodeListNavigatorIssues [--glob <glob>] [--pattern <pattern>] [--severity <severity>] --tab-identifier <tab-identifier> [--raw <json>]")
	.description("Lists the currently known issues shown Xcode's Issue Navigator UI in the workspace. These issues include those that have been discovered since the last build, and also issues like package resolution problems and workspace configuration issues. You can filter the issues to include by file name, glob, or severity. Use this tool when you want to list all the users the user can see in the workspace UI.")
	.usage("[--glob <glob>] [--pattern <pattern>] [--severity <severity>] --tab-identifier <tab-identifier> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--glob <glob>", "Glob to filter the returned issues. Will match against the 'path' field.")
	.option("--pattern <pattern>", "Regex to filter the returned issues. Will match against the 'message' field.")
	.option("--severity <severity>", "Limit the returned issues to those that have the specified severity or higher. Valid values in order of decreasing severity are 'error', 'warning', 'remark'. Defaults to 'error'.")
	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (example: example-id)")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.glob !== undefined) args.glob = cmdOpts.glob;
		if (cmdOpts.pattern !== undefined) args.pattern = cmdOpts.pattern;
		if (cmdOpts.severity !== undefined) args.severity = cmdOpts.severity;
		if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
			const call = (proxy.xcodeListNavigatorIssues as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.XcodeListNavigatorIssues(tabIdentifier: \"example-id\")");

program
	.command("XcodeMakeDir")
	.summary("XcodeMakeDir --directory-path <directory-path> --tab-identifier <tab-identifier> [--raw <json>]")
	.description("Creates directories and groups in the Xcode project structure.")
	.usage("--directory-path <directory-path> --tab-identifier <tab-identifier> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--directory-path <directory-path>", "Project navigator relative path for the directory to create (example: /path/to/file.md)")
	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (example: example-id)")
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.directoryPath !== undefined) args.directoryPath = cmdOpts.directoryPath;
		if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
			const call = (proxy.xcodeMakeDir as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.XcodeMakeDir(directoryPath: \"/path/to/file.md\", ta, ...)");

program
	.command("ExecuteSnippet")
	.summary("ExecuteSnippet --code-snippet <code-snippet> --source-file-path <source-file-path> --tab-identifier <tab-identifier> [--timeout <timeout:number>] [--raw <json>]")
	.description("Builds and runs a snippet of code in the context of a specific file and waits until results are available. This tool is available for source files in targets that build applications, frameworks, libraries, or command line executables. The output consists of the console output generated by the `print` statements contained in the provided snippet.")
	.usage("--code-snippet <code-snippet> --source-file-path <source-file-path> --tab-identifier <tab-identifier> [--timeout <timeout:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--code-snippet <code-snippet>", "The code snippet that should be executed in the context of the specified file.")
	.requiredOption("--source-file-path <source-file-path>", "The path to a Swift source file within the Xcode project organization (e.g., 'ProjectName/Sources/MyFile.swift') whose context the code snippet will have access to (including `fileprivate` declarations). (example: /path/to/file.md)")
	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier. (example: example-id)")
	.option("--timeout <timeout:number>", "The time in seconds to wait for the execution of the snippet to complete. Defaults to 120 seconds. (example: 1)", (value) => parseFloat(value))
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.codeSnippet !== undefined) args.codeSnippet = cmdOpts.codeSnippet;
		if (cmdOpts.sourceFilePath !== undefined) args.sourceFilePath = cmdOpts.sourceFilePath;
		if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
		if (cmdOpts.timeout !== undefined) args.timeout = cmdOpts.timeout;
			const call = (proxy.executeSnippet as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.ExecuteSnippet(codeSnippet: \"value\", sourceFilePat, ...)");

program
	.command("RenderPreview")
	.summary("RenderPreview [--preview-definition-index-in-file <preview-definition-index-in-file:number>] --source-file-path <source-file-path> --tab-identifier <tab-identifier> [--timeout <timeout:number>] [--raw <json>]")
	.description("Builds and renders a Preview and waits until a snapshot of the resulting UI is available.")
	.usage("[--preview-definition-index-in-file <preview-definition-index-in-file:number>] --source-file-path <source-file-path> --tab-identifier <tab-identifier> [--timeout <timeout:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--preview-definition-index-in-file <preview-definition-index-in-file:number>", "The zero based index of the #Preview macro or PreviewProvider struct definition in the source file counting from the top. Defaults to 0, i.e. the first one. (example: 1)", (value) => parseFloat(value))
	.requiredOption("--source-file-path <source-file-path>", "The path to the file within the Xcode project organization (e.g., 'ProjectName/Sources/MyFile.swift') (example: /path/to/file.md)")
	.requiredOption("--tab-identifier <tab-identifier>", "The workspace tab identifier (example: example-id)")
	.option("--timeout <timeout:number>", "The time in seconds to wait for the rendering of the preview to complete. Defaults to 120 seconds. (example: 1)", (value) => parseFloat(value))
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.previewDefinitionIndexInFile !== undefined) args.previewDefinitionIndexInFile = cmdOpts.previewDefinitionIndexInFile;
		if (cmdOpts.sourceFilePath !== undefined) args.sourceFilePath = cmdOpts.sourceFilePath;
		if (cmdOpts.tabIdentifier !== undefined) args.tabIdentifier = cmdOpts.tabIdentifier;
		if (cmdOpts.timeout !== undefined) args.timeout = cmdOpts.timeout;
			const call = (proxy.renderPreview as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call mcpbridge.RenderPreview(previewDefinitionIndexInFile: 1, sou, ...)");

program
	.command('__mcporter_inspect', { hidden: true })
	.description('Internal metadata printer for mcporter inspect-cli.')
	.action(() => {
		const payload = buildMetadataPayload();
		console.log(JSON.stringify(payload, null, 2));
	});

configureToolCommandHelps();

const FORCE_COLOR = process.env.FORCE_COLOR?.toLowerCase();
const forceDisableColor = FORCE_COLOR === '0' || FORCE_COLOR === 'false';
const forceEnableColor = FORCE_COLOR === '1' || FORCE_COLOR === 'true' || FORCE_COLOR === '2' || FORCE_COLOR === '3';
const hasNoColor = process.env.NO_COLOR !== undefined;
const stdoutStream = process.stdout as NodeJS.WriteStream | undefined;
const supportsAnsiColor = !hasNoColor && (forceEnableColor || (!forceDisableColor && Boolean(stdoutStream?.isTTY)));

const tint = {
	bold(text: string): string {
		return supportsAnsiColor ? '[1m' + text + '[0m' : text;
	},
	dim(text: string): string {
		return supportsAnsiColor ? '[90m' + text + '[0m' : text;
	},
	extraDim(text: string): string {
		return supportsAnsiColor ? '[38;5;244m' + text + '[0m' : text;
	},
};

function configureGeneratedCommandHelp(command: Command): void {
	command.configureHelp({
		commandUsage(target) {
			const usage = (target.name() + ' ' + target.usage()).trim() || target.name();
			return supportsAnsiColor ? tint.bold(usage) : usage;
		},
		optionTerm(option) {
			const term = option.flags ?? '';
			return supportsAnsiColor ? tint.bold(term) : term;
		},
		optionDescription(option) {
			const description = option.description ?? '';
			return supportsAnsiColor ? tint.extraDim(description) : description;
		},
	});
}

function configureToolCommandHelps(): void {
	program.commands.forEach((cmd) => {
		if (cmd.name() === '__mcporter_inspect') {
			return;
		}
		configureGeneratedCommandHelp(cmd);
	});
}

function renderStandaloneHelp(): string {
	const colorfulTitle = tint.bold(embeddedName) + ' ' + tint.dim('â€” ' + embeddedDescription);
	const plainTitle = embeddedName + ' â€” ' + embeddedDescription;
	const title = supportsAnsiColor ? colorfulTitle : plainTitle;
	const lines = [title, '', 'Usage: ' + embeddedName + ' <command> [options]', ''];
	if (generatorTools) {
		lines.push(formatEmbeddedTools());
	}
	lines.push('', formatGlobalFlags(), '', formatQuickStart());
	if (generatorInfo) {
		lines.push('', tint.extraDim(generatorInfo));
	}
	return lines.join('\n');
}

program.helpInformation = () => renderStandaloneHelp();

function formatEmbeddedTools(): string {
	const header = supportsAnsiColor ? tint.bold('Embedded tools') : 'Embedded tools';
	if (!generatorTools.length) {
		return header;
	}
	const lines = [header];
	generatorTools.forEach((entry) => {
		const renderedDesc = entry.description
			? supportsAnsiColor
				? tint.extraDim(entry.description)
				: entry.description
			: undefined;
		const base = renderedDesc ? entry.name + ' - ' + renderedDesc : entry.name;
		lines.push('  ' + base);
		if (entry.flags) {
			const renderedFlags = supportsAnsiColor ? tint.extraDim(entry.flags) : entry.flags;
			lines.push('    ' + renderedFlags);
		}
		lines.push('');
	});
	if (lines[lines.length - 1] === '') {
		lines.pop();
	}
	return lines.join('\n');
}

function formatGlobalFlags(): string {
	const header = supportsAnsiColor ? tint.bold('Global flags') : 'Global flags';
	const entries = [
		['-t, --timeout <ms>', 'Call timeout in milliseconds'],
		['-o, --output <format>', 'text | markdown | json | raw (default text)'],
	];
	const formatted = entries.map(([flag, summary]) => '  ' + flag.padEnd(28) + summary);
	return [header, ...formatted].join('\n');
}

function formatQuickStart(): string {
  const header = supportsAnsiColor ? tint.bold('Quick start') : 'Quick start';
  const examples = quickStartExamples();
  if (!examples.length) {
    return header;
  }
  const formatted = examples.map(([cmd, note]) => '  ' + cmd + '\n    ' + tint.dim('# ' + note));
  return [header, ...formatted].join('\n');
}

function quickStartExamples(): Array<[string, string]> {
  const examples: Array<[string, string]> = [];
  const commandMap = new Map<string, string>();
  program.commands.forEach((cmd) => {
    const name = cmd.name();
    if (name !== '__mcporter_inspect') {
      commandMap.set(name, name);
    }
  });
  const embedded = Array.isArray(generatorTools) ? generatorTools : [];
  for (const entry of embedded.slice(0, 3)) {
    const commandName = commandMap.get(entry.name) ?? entry.name;
    const flags = entry.flags ? ' ' + entry.flags.replace(/<[^>]+>/g, '<value>') : '';
    examples.push([embeddedName + ' ' + commandName + flags, 'invoke ' + commandName]);
  }
  if (!examples.length) {
    examples.push([embeddedName + ' <tool> --key value', 'invoke a tool with flags']);
  }
  return examples;
}

function printResult(result: unknown, format: string) {
	const wrapped = createCallResult(result);
	switch (format) {
		case 'json': {
			const json = wrapped.json();
			if (json) {
				console.log(JSON.stringify(json, null, 2));
				return;
			}
			break;
		}
		case 'markdown': {
			const markdown = wrapped.markdown();
			if (markdown) {
				console.log(markdown);
				return;
			}
			break;
		}
		case 'raw': {
			console.log(JSON.stringify(wrapped.raw, null, 2));
			return;
		}
	}
	const text = wrapped.text();
	if (text) {
		console.log(text);
	} else {
		console.log(JSON.stringify(wrapped.raw, null, 2));
	}
}

function normalizeEmbeddedServer(server: typeof embeddedServer) {
	const base = { ...server } as Record<string, unknown>;
	if ((server.command as any).kind === 'http') {
		const urlRaw = (server.command as any).url;
		const urlValue = typeof urlRaw === 'string' ? urlRaw : String(urlRaw);
		return {
			...base,
			command: {
				...(server.command as Record<string, unknown>),
				url: new URL(urlValue),
			},
		};
	}
	if ((server.command as any).kind === 'stdio') {
		return {
			...base,
			command: {
				...(server.command as Record<string, unknown>),
				args: [ ...((server.command as any).args ?? []) ],
			},
		};
	}
	return base;
}

function determineArtifactKind(): 'template' | 'bundle' | 'binary' {
	const scriptPath = typeof process !== 'undefined' && Array.isArray(process.argv) ? process.argv[1] ?? '' : '';
	if (scriptPath.endsWith('.ts')) {
		return 'template';
	}
	if (scriptPath.endsWith('.js')) {
		return 'bundle';
	}
	return 'binary';
}

function resolveArtifactPath(): string {
	if (typeof process !== 'undefined' && Array.isArray(process.argv) && process.argv.length > 1) {
		const script = process.argv[1];
		if (script) {
			return script;
		}
	}
	return embeddedMetadata.artifact.path;
}

function buildMetadataPayload() {
	const invocation = { ...embeddedMetadata.invocation };
	const path = resolveArtifactPath();
	if (artifactKind === 'template' && path) {
		invocation.outputPath = invocation.outputPath ?? path;
	} else if (artifactKind === 'bundle' && path) {
		invocation.bundle = invocation.bundle ?? path;
	} else if (artifactKind === 'binary' && path) {
		invocation.compile = invocation.compile ?? path;
	}
	return {
		...embeddedMetadata,
		artifact: {
			path,
			kind: artifactKind,
		},
		invocation,
	};
}

async function ensureRuntime(): Promise<Awaited<ReturnType<typeof createRuntime>>> {
	return await createRuntime({
		servers: [normalizeEmbeddedServer(embeddedServer)],
	});
}

async function invokeWithTimeout<T>(call: Promise<T>, timeout: number): Promise<T> {
	if (!Number.isFinite(timeout) || timeout <= 0) {
		return await call;
	}
	let timer: ReturnType<typeof setTimeout> | undefined;
	try {
		return await Promise.race([
			call,
			new Promise<never>((_, reject) => {
				timer = setTimeout(() => {
					reject(new Error('Call timed out after ' + timeout + 'ms.'));
				}, timeout);
			}),
		]);
	} finally {
		if (timer) {
			clearTimeout(timer);
		}
	}
}

async function runCli(): Promise<void> {
	const args = process.argv.slice(2);
	if (args.length === 0) {
		program.outputHelp();
		return;
	}
	await program.parseAsync(process.argv);
}

if (process.env.MCPORTER_DISABLE_AUTORUN !== '1') {
	runCli().catch((error) => {
		const message = error instanceof Error ? error.message : String(error);
		console.error(message);
		process.exit(1);
	});
}
